# -----------------------------------------------------------------------------
# Purpose:     Rewrite functions so that parameters are passed in as arguments
#              so that values can be generated by ChatGPT.
#
# Format:      Every action is written as a class, with a single function. The
#              class init consists of system setups that user does not need to
#              know. Each function takes in a config dictionary with parameters
#              that can be generated by ChatGPT.
#
# Notes:       Functions are not well written. Please see comments in corresponding
#              txt file: char_fiveActions_errors.txt
#
# Functions:   (Working) pingTarget, openURL, openWord, cloneRepo, runOneCmd,
#              cloneRepo, holdZoom, takeScreenshot, sendTelegram, sendEmail
# -----------------------------------------------------------------------------

# Ping
import os
import subprocess
from pythonping import ping

# Browser
import time
from selenium import webdriver
from selenium.webdriver.chrome.service import Service as ChromeService
from webdriver_manager.chrome import ChromeDriverManager

# Word
import keyboard

# Nmap
import nmap

# Git Downloader
from git import Repo

# Web Screenshot
import os
import sys
from time import sleep
from datetime import datetime
from selenium import webdriver

# Import QT web API to capture the web page screen shot.
from PyQt5.QtWidgets import QApplication
from PyQt5.QtCore import Qt, QUrl, QTimer
from PyQt5.QtWebEngineWidgets import QWebEngineView, QWebEngineSettings

# Import selenium webdriver API to capture the web page screen shot.
# https://pypi.org/project/webdriver-manager/
from selenium import webdriver
from selenium.webdriver.chrome.service import Service as ChromeService
from webdriver_manager.chrome import ChromeDriverManager

from selenium.webdriver.chrome.service import Service

QT_DRIVER = 1
CH_DRIVER = 2

# Telegram
import requests

# Email
import smtplib
from email.mime.text import MIMEText



from UtilsFunc import funcActor
import json


PORT = 443

# -----------------------------------------------------------------------------
# Action 01: Ping targets sequence or parallel
# -----------------------------------------------------------------------------

class pingTargetActor(object): 

    def __init__(self) -> None:  
        self._pingTimeout = 1    # ping timeout setting, default set to 1 sec.

    def pingTarget(self, pingTargetConfig):

        print('---------- Running runPing')
       
       # Parameters
        ipAddress = pingTargetConfig['ipAddress']
        pingInterval = pingTargetConfig['pingInterval']
        pingEchoNum = pingTargetConfig['pingEchoNum']

        # Show on console.
        def pingFunc(ipAddress, pingEchoNum):
            pingCmd = "ping -n %s %s" % (str(pingEchoNum), ipAddress)
            try:
                result = subprocess.call(pingCmd, creationflags=subprocess.CREATE_NEW_CONSOLE)
                # crtPingRst = {}
                # data = ping(ipAddress, timeout=self._pingTimeout, verbose=False)
                # time.sleep(pingInterval)
                # crtPingRst[str(ipAddress)].append(data.rtt_avg_ms)
                return result
            except Exception as err:
                print('Pop the console terminal failed: %s' % str(err))
                return False
            
        pingFunc(ipAddress, pingEchoNum)
        time.sleep(pingInterval)

# -----------------------------------------------------------------------------
# Action 02: Capture webpage screen shot
# -----------------------------------------------------------------------------

class QTCapture(QWebEngineView):
    """ Capture the web page screen shot with QT5<QtWebEngineWidgets> driver."""
    # Reference link:
    # https://zetcode.com/pyqt/qwebengineview/
    # https://stackoverflow.com/questions/55231170/taking-a-screenshot-of-a-web-page-in-pyqt5
    # https://stackoverflow.com/questions/51154871/python-3-7-0-no-module-named-pyqt5-qtwebenginewidgets
    webSize = (1024, 768) # default web page size

    #-----------------------------------------------------------------------------
    # Init the private function here:
    def _onLoaded(self):
        #self.resize(self.page().contentsSize().toSize()) # Wait for resize
        self.resize(self.webSize[0], self.webSize[1])
        QTimer.singleShot(1000, self._takeScreenshot)

    def _takeScreenshot(self):
        self.grab().save(self.outputFile, b'PNG')
        if self.app: self.app.quit()

    #-----------------------------------------------------------------------------
    def captureQT(self, url, outDirPath, outputName=None):
        """ Capture the web page screen shot with QT5<QtWebEngineWidgets> driver.
            Args:
                url (str): url string
                outDirPath (str): output directory path.
                outputName (str, optional): output image file. Defaults to None, then 
                    the program will create image under format: shot_yymmdd_hhmmss.png
            Returns:
                bool: true if catpure successful else false.
        """
        picName = outputName if outputName else "shot_" + datetime.now().strftime("%Y%m%d_%H%M%S")+'.png'
        self.outputFile = os.path.join(outDirPath, picName)
        try:
            self.load(QUrl(url))
            self.loadFinished.connect(self._onLoaded)
            # Create hidden view without scrollbars
            self.setAttribute(Qt.WA_DontShowOnScreen)
            self.page().settings().setAttribute(QWebEngineSettings.ShowScrollBars, False)
            self.show()
            return True
        except Exception as err:
            print("Error > captureQT() capture error: %s" % str(err))
            return False

    #-----------------------------------------------------------------------------
    def setImgSize(self, sizeTuple):
        self.webSize = sizeTuple

#-----------------------------------------------------------------------------
# Action 02: Capture webpage screen shot
#-----------------------------------------------------------------------------
class takeScreenshotActor(object):
    """ Webpage screenshot capture module."""
    def __init__(self):
        # Init the Chrome capture dirver.
        self.chDriver = None
        # Init the QT capture App
        self.qtApp = QApplication(sys.argv)
        self.qtDriver = QTCapture()
        self.qtDriver.app = self.qtApp

    def setQTimgSz(self, sizeTuple):
        if self.qtDriver: self.qtDriver.setImgSize(sizeTuple)

    def takeScreenShot(self, takeScreenshotConfig):

        print('---------- Running getScreenshot')
        print("Start the Web screenshoter")

        url = takeScreenshotConfig['url']
        outDirPath = takeScreenshotConfig['outputFolder']
        driverMode = takeScreenshotConfig['driverMode']

        if driverMode == QT_DRIVER:
            self.qtDriver.captureQT(url, outDirPath)
            self.qtApp.exec_()
        elif driverMode == CH_DRIVER:
            self._capturePage(url, outDirPath)
        else:
            print("> Error: the capture driver mode:[%s] is not defined." %str(driverMode))
            return False
        
        print('Finished')
        self.stop()
        return True

    def _capturePage(self, url, outDirPath, outputName=None):
        """ Capture the url screen shot by google browser driver API.
            Args:
                url ([string]): web url string.
                outputDir ([string]): folder path to save the web components.
        """
        try:
            self.chDriver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()))
            self.chDriver.get(url)
            sleep(1) # wait one second to let the browser to show the whole webpage
            picName = outputName if outputName else "shot_"+datetime.now().strftime("%Y%m%d_%H%M%S")+'.png'
            outputFile = os.path.join(outDirPath, picName)
            self.chDriver.get_screenshot_as_file(outputFile)
            self.chDriver.quit()
            return True
        except Exception as err:
            print("Error > _capturePage() capture error: %s" % str(err))
            self.chDriver.quit()
            return False
    
    def stop(self):
        if self.chDriver: self.chDriver.quit()
        if self.qtApp: self.qtApp.quit()



# -----------------------------------------------------------------------------
# Action 12: Send and Receive Email
# -----------------------------------------------------------------------------
# https://www.sitepoint.com/quick-tip-sending-email-via-gmail-with-python/
# User needs to do the following: Manage your Google Account > Security > 2-step Verification
# Then, create an App Password.

# [DO THIS]
# DO PULL EMAIL: Call direction, get index, and ask for index. direcotry listing, randomly pull index, and get directory[index].
# Separate the login and send email.

class sendEmailActor(object):
    def __init__(self):
        pass

    def sendEmail(self, sendEmailConfig):

        GMAIL_USERNAME = sendEmailConfig['username']
        GMAIL_APP_PASSWORD = sendEmailConfig['appPassword']

        recipients = [sendEmailConfig['recipients']]
        msg = MIMEText(sendEmailConfig['message'])
        msg["Subject"] = sendEmailConfig['subject']
        msg["To"] = ", ".join(recipients)
        msg["From"] = f"{GMAIL_USERNAME}@gmail.com"

        smtp_server = smtplib.SMTP_SSL('smtp.gmail.com', 465)
        smtp_server.login(GMAIL_USERNAME, GMAIL_APP_PASSWORD)
        smtp_server.sendmail(msg["From"], recipients, msg.as_string())
        smtp_server.quit()


# -----------------------------------------------------------------------------
# Action 13: Use browser to open URL
# -----------------------------------------------------------------------------

class openURLActor(object):
    def __init__(self, driverPath=None) -> None:
        self.path = "C:\\Users\\leech\\Downloads\\chromedriver-win64\\chromedriver-win64\\chromedriver.exe"
        #self. service = Service(executable_path = self.path)
        #self.driver = webdriver.Chrome(service = self.service)
        self.driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()))
        self.startT = 0
    
    def openURL(self, urlConfig):

        print('---------- Running openUrl')

        # Parameters
        openURL = urlConfig['url']
        watchInterval = urlConfig['watchInterval']

        try:
            urlStr = urlConfig if isinstance(urlConfig, str) else openURL
            self.driver.get(urlStr)
        except Exception as err:
            print('Ignore some internet not access exception %s' %str(err))
        if isinstance(urlConfig, dict) and 'interval' in urlConfig.keys():
            time.sleep(watchInterval)

        # try:
        #     self.driver.get(openURL)
        #     #if isinstance(urlConfig, dict) and 'interval' in urlConfig.keys():
        #     time.sleep(watchInterval)
        # except Exception as err:
        #     print('Ignore some internet not access exception %s' %str(err))
  
    def closeBrowser(self):
        self.driver.quit()

# -----------------------------------------------------------------------------
# Action 17: Edit a PPT file (Open Word doc)
# -----------------------------------------------------------------------------

class openWordActor(object):
    def __init__(self):
        pass

    def openWord(self, openWordConfig):

        print('---------- Running openWord')

        # Parameters
        filePath = openWordConfig['filePath']
        dirPath, fileName = os.path.split(filePath)
        openInterval = openWordConfig['openInterval']

        opencmd = [
            {   'cmdID': 'openWordDoc',
                'console': False,
                'cmdStr': 'start %s' %str(dirPath),
                'winShell': True,
                'repeat': 1,
                'interval': 1        },

            {   'cmdID': 'closeWordDoc',
                'console': False,
                'cmdStr': 'start %s' %str(filePath),
                'winShell': True,
                'repeat': 1,
                'interval': openInterval # 0.8
            }
        ]
        funcActor.runWinCmds(opencmd, rstRecord=False)

        # Close the word doc.
        keyboard.press_and_release('alt+f4')
        #time.sleep(openInterval)
        #keyboard.press_and_release('enter')
        #time.sleep(1)

# -----------------------------------------------------------------------------
# Action 18: Start a Zoom meeting
# -----------------------------------------------------------------------------

class holdZoomActor(object):

    def __init__(self):
        #self.userName = userName
        self.path = "C:\\Users\\leech\\Downloads\\chromedriver-win64\\chromedriver-win64\\chromedriver.exe"
        self. service = Service(executable_path = self.path)
        self.driver = webdriver.Chrome(service = self.service)
        # self.driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()))
        self.appFlg = False # The zoom is open in a App

    def _keyboardPress(self, keyStr):
        time.sleep(0.3)
        keyboard.press_and_release(keyStr)
        time.sleep(0.3)

    def holdZoom(self, zoomMeetingConfig, appFlg=True):
        try:
            self.driver.get(zoomMeetingConfig['meetingURL'])
        except Exception as err:
            print("Start meeting url failed")
            return False
        
        self.appFlg = appFlg
        if self.appFlg:
            # Click accept the zoom meeting in the web pop-up window.
            self._keyboardPress('tab')
            self._keyboardPress('tab')
            self._keyboardPress('enter')
            # wait 15 second for the zoom start 
            time.sleep(15)
            # accept the use compute audo eable
            self._keyboardPress('enter')

        else:
            # use the API to accept the "open ZOOM in app"
            #obj = self.driver.switch_to.alert
            #time.sleep(1)
            #print(obj.text)
            pass

        time.sleep(10)
        self.endCrtMeeting()
        print("Finish")


    def endCrtMeeting(self):
        # use hotkey to close the zoom
        # close the zoom.  
        self._keyboardPress('alt+f4')
        self._keyboardPress('enter')
        self._keyboardPress('alt+f4')
        # close the browser 
        time.sleep(3)


# -----------------------------------------------------------------------------
# Action 19: Git download/pull the project
# -----------------------------------------------------------------------------

class cloneRepoActor(object):

    def __init__(self) -> None:
        pass

    def cloneRepo(self, cloneRepoConfig):
        
        print('---------- Running cloneRepo')

        repoName = cloneRepoConfig['repoName']
        repoURL = cloneRepoConfig['repoURL']

        print("Start cloning repo: %s" %str(repoName) )
        success = False

        targetFld = os.path.join(cloneRepoConfig['dirPath'], cloneRepoConfig['repoName'])
        try:
            if not os.path.exists(targetFld):
                os.mkdir(targetFld)
            repo = Repo.clone_from(cloneRepoConfig['repoURL'], targetFld)
            success = True
        
        except Exception as err:
            print("error: %s" %str(err))
            success = False
            
        if success == True:
            print("Finished")
        else:
            print("Failed")
# -----------------------------------------------------------------------------
# Action 25: Use Nmap to scan the network
# -----------------------------------------------------------------------------

# -----------------------------------------------------------------------------
# Action 31: Send chat message via Telegram
# -----------------------------------------------------------------------------
# Script from ChatGPT
# User needs to create a Telebot and recipients need to activate the Telebot with /start.
# User needs to know recipients' chat ID.

class sendTelegramActor(object):
    def __init__(self):
        pass

    def sendTelegram(self, sendTelegramConfig):
        url = f'https://api.telegram.org/bot{sendTelegramConfig["token"]}/sendMessage'
        payload = {
            'chat_id': sendTelegramConfig['chatID'],
            'text': sendTelegramConfig['message']
        }
        response = requests.post(url, data=payload)
        return response.json()
 

# -----------------------------------------------------------------------------
# Action 34: Run commands on different system
# -----------------------------------------------------------------------------

class runOneCmdActor(object):
    def __init__(self):
        pass

    def runOneCmd(self, runOneCmdConfig, rstRecord=False):

        print('---------- Running runOneCmd')

        cmdList = [runOneCmdConfig]
        resultDict = {} if rstRecord else None
        
        # execute the cmds
        for item in cmdList:
            print('Check item in cmdList:', item)
            for _ in range(int(item['repeat'])):
                print('winShell' in item.keys())
                shell = True if 'winShell' in item.keys() else False
                rst = funcActor.runCmd(item['cmdStr'], showConsole=item['console'], winShell=shell)

                if rstRecord: resultDict[str(item['cmdID'])] = rst
                time.sleep(float(item['interval']))
            print("Finish execute cmd with ID: %s" %str(item['cmdID']))
        
        return resultDict

# -----------------------------------------------------------------------------
# Test above actions
# -----------------------------------------------------------------------------

actions_list = ['pingTarget', 'openURL', 'openWord', 'runOneCmd', 'cloneRepo', 'holdZoom', 'takeScreenshot', 'sendTelegram', 'sendEmail']

def testCase(action):

    if action == 0:
        pass
    
    elif action == 'pingTarget':
        
        pingTargetConfig = {
            'ipAddress': 'www.youtube.com',
            'pingInterval': 0.1, # sleep interval between each 2 ping, default set to 0.1 sec.
            'pingEchoNum': 5,
            'pingTimeout': 1 # ping timeout setting, default set to 1 sec.
        }

        actor = pingTargetActor()
        actor.pingTarget(pingTargetConfig)
    
    elif action == 'openURL':
        openURLConfig = {
            'url': 'https://github.com/LiuYuancheng/Cluster_User_Emulation_System/blob/main/README.md',
            'watchInterval':  10 # time interval to wait for next operation.
            }

        actor = openURLActor()
        actor.openURL(openURLConfig)
        #time.sleep(urlConfig['interval'])
        #actor.closeBrowser()

    elif action == 'openWord':
        openWordConfig = {
            'filePath': 'C:\\Users\\leech\\OneDrive\\Desktop\\Report.docx',
            'openInterval': 10,
        }

        actor = openWordActor()
        actor.openWord(openWordConfig)

    elif action == 'runOneCmd':
        runOneCmdConfig = {
            "cmdID": "cmd_1",
            "console": True,
            "cmdStr": "ping -n 5 www.google.com.sg",
            "repeat": 1,
            "interval": 0.8
        }

        actor = runOneCmdActor()
        result = actor.runOneCmd(runOneCmdConfig, rstRecord=True)
        print('Result: ', result)

    elif action == 'nmapScan':
        nmapConfig = {
            'target': 'localhost',
            'portList': [80, 443, 8080],
        }

        # actor = nmapScanner()
        # actor.scanTcpPorts(nmapConfig)
        os.subprocess.call("nmap -sC -sV <ip>", shell=True)

    elif action == 'cloneRepo':
        cloneRepoConfig = {
            'dirPath': "C:\\Users\\leech\\Downloads\\00. School\\Capstone\\Cluster_User_Emulation_System-main\\src\\actionScheduler\\UtilsFunc",
            'repoName': "MCQ-GPT-Bot2",
            'repoURL': "https://github.com/LiuYuancheng/MCQ-GPT-Bot.git",
        }        

        actor = cloneRepoActor()
        actor.cloneRepo(cloneRepoConfig)

    elif action =='holdZoom':
        holdZoomConfig = {
            'username': 'TestUser_Bob',
            'meetingURL': 'https://us04web.zoom.us/j/4580466160?pwd=d0ZUSCs0bWpMc2o2MHgzTS80a2tJdz09'
        }
        
        actor = holdZoomActor()
        actor.holdZoom(holdZoomConfig)

    elif action == 'takeScreenshot':

        takeScreenshotConfig = {
            "url": "https://www.neopets.com/",
            "outputFolder": "C:\\Users\\leech\\Downloads\\00. School\\Capstone\\Cluster_User_Emulation_System-main\\src\\actionScheduler\\outputFolder",
            "driverMode" : 1 # 1: QT5 QtWebEngineWidgets driver, 2: Selenium Chrome driver
            }

        actor = takeScreenshotActor()
        actor.takeScreenShot(takeScreenshotConfig)

    elif action == 'sendTelegram':
        sendTelegramConfig = {
            'token' : '6725278465:AAFgXrznCf9vXkHUDGc8aoBJG6qEv3xxQrY',
            'chatID': '448238802', # User to send message to. User needs to activate chat ID.
            'message': 'Hello, World!'
        }

        actor = sendTelegramActor()
        actor.sendTelegram(sendTelegramConfig)

    elif action == 'sendEmail':
        sendEmailConfig = {
            'username': 'nus.capstone.test',
            'appPassword': 'exqrbskdajyjmnuj',
            'recipients': 'nus.capstone.test@gmail.com',
            'subject': 'Test Email2',
            'message': 'Hello, World!'
        }

        actor = sendEmailActor()
        actor.sendEmail(sendEmailConfig)


if __name__ == '__main__':
    testCase(action = "sendEmail")

    # errors: openURL, holdZoom